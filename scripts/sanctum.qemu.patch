From 7641eea2a948fe8775ceeb156d60c63d0be3f22d Mon Sep 17 00:00:00 2001
From: Ilia Lebedev <ilebedev@mit.edu>
Date: Sat, 27 Oct 2018 16:29:25 -0400
Subject: [PATCH 1/2] sanctum simulator hardware

---
 disas/riscv.c            |  14 ++++
 hw/riscv/Makefile.objs   |   1 +
 hw/riscv/boot.c          |  13 ++--
 hw/riscv/puf.c           | 129 ++++++++++++++++++++++++++++++++++++
 hw/riscv/spike.c         | 102 ++++++++++++++++++++++++----
 hw/riscv/virt.c          |  37 +++++++++--
 include/hw/riscv/puf.h   |  32 +++++++++
 include/hw/riscv/spike.h |   2 +
 include/hw/riscv/virt.h  |   1 +
 target/riscv/cpu.h       |  36 ++++++++++
 target/riscv/cpu_bits.h  |  45 +++++++++++++
 target/riscv/csr.c       | 140 ++++++++++++++++++++++++++++++++++++++-
 target/riscv/pmp.c       |   2 +-
 target/riscv/trng.h      |   8 +++
 14 files changed, 538 insertions(+), 24 deletions(-)
 create mode 100644 hw/riscv/puf.c
 create mode 100644 include/hw/riscv/puf.h
 create mode 100644 target/riscv/trng.h

diff --git a/disas/riscv.c b/disas/riscv.c
index cd4f377ed9..4774579be4 100644
--- a/disas/riscv.c
+++ b/disas/riscv.c
@@ -1227,6 +1227,17 @@ static const char *csr_name(int csrno)
     case 0x07b0: return "dcsr";
     case 0x07b1: return "dpc";
     case 0x07b2: return "dscratch";
+    // <SANCTUM>
+    case 0x07c0: return "mevbase";
+    case 0x07c1: return "mevmask";
+    case 0x07c2: return "meatp";
+    case 0x07c3: return "mmrbm";
+    case 0x07c4: return "memrbm";
+    case 0x07c5: return "mparbase";
+    case 0x07c6: return "mparmask";
+    case 0x07c7: return "meparbase";
+    case 0x07c8: return "meparmask";
+    // </SANCTUM>
     case 0x0b00: return "mcycle";
     case 0x0b01: return "mtime";
     case 0x0b02: return "minstret";
@@ -1297,6 +1308,9 @@ static const char *csr_name(int csrno)
     case 0x0c80: return "cycleh";
     case 0x0c81: return "timeh";
     case 0x0c82: return "instreth";
+    // <SANCTUM>
+    case 0x0cc0: return "trng";
+    // </SANCTUM>
     case 0x0d00: return "scycle";
     case 0x0d01: return "stime";
     case 0x0d02: return "sinstret";
diff --git a/hw/riscv/Makefile.objs b/hw/riscv/Makefile.objs
index d903933dc7..eb3b8141df 100644
--- a/hw/riscv/Makefile.objs
+++ b/hw/riscv/Makefile.objs
@@ -9,5 +9,6 @@ obj-y += sifive_plic.o
 obj-y += sifive_test.o
 obj-y += sifive_u.o
 obj-y += sifive_uart.o
+obj-y += puf.o
 obj-y += spike.o
 obj-y += virt.o
diff --git a/hw/riscv/boot.c b/hw/riscv/boot.c
index cf4e5d5946..9e9b3b6842 100644
--- a/hw/riscv/boot.c
+++ b/hw/riscv/boot.c
@@ -46,6 +46,7 @@ static uint64_t kernel_translate(void *opaque, uint64_t addr)
     }
 }

+/*
 hwaddr riscv_load_firmware(const char *filename)
 {
     uint64_t firmware_entry, firmware_start, firmware_end;
@@ -57,19 +58,23 @@ hwaddr riscv_load_firmware(const char *filename)
         exit(1);
     }

-    /* align kernel load address to the megapage after the firmware */
+    // align kernel load address to the megapage after the firmware
 #if defined(TARGET_RISCV32)
     kernel_offset = (firmware_end + 0x3fffff) & ~0x3fffff;
 #else
     kernel_offset = (firmware_end + 0x1fffff) & ~0x1fffff;
 #endif

+    //Do not ever relocate kernel... (firmware is not always bbl)
+    kernel_offset = 0;
+
     boot_debug("entry=0x" TARGET_FMT_plx " start=0x" TARGET_FMT_plx " "
                "end=0x" TARGET_FMT_plx " kernel_offset=0x" TARGET_FMT_plx "\n",
                firmware_entry, firmware_start, firmware_end, kernel_offset);

     return firmware_entry;
 }
+*/

 hwaddr riscv_load_kernel(const char *filename, void *fdt)
 {
@@ -148,9 +153,9 @@ hwaddr riscv_load_firmware_kernel_initrd(MachineState *machine, void *fdt)
     hwaddr firmware_entry = 0;

     /* load firmware e.g. -bios bbl */
-    if (machine->firmware) {
-        firmware_entry = riscv_load_firmware(machine->firmware);
-    }
+    //if (machine->firmware) {
+    //    firmware_entry = riscv_load_firmware(machine->firmware);
+    //}

     /* load combined bbl+kernel or separate kernel */
     if (machine->kernel_filename) {
diff --git a/hw/riscv/puf.c b/hw/riscv/puf.c
new file mode 100644
index 0000000000..1a072cfad9
--- /dev/null
+++ b/hw/riscv/puf.c
@@ -0,0 +1,129 @@
+/*
+ * PUF
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "hw/sysbus.h"
+#include "target/riscv/cpu.h"
+#include "hw/riscv/puf.h"
+#include "qemu/timer.h"
+
+/* CPU wants to read the puf */
+static uint64_t puf_read(void *opaque, hwaddr addr, unsigned size)
+{
+    PUFState *puf = opaque;
+
+    /* reads must be 8 byte aligned words */
+    if ((addr & 0x7) != 0 || size != 8) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+            "clint: invalid read size %u: 0x%" HWADDR_PRIx "\n", size, addr);
+        return 0L;
+    }
+
+    if (addr == PUF_SELECT) {
+        /* puf_select */
+        return puf->puf_select;
+    } else if (addr == PUF_READOUT) {
+        /* puf_readout */
+        return 0xDEADBEEFL; /* TODO: implement some function of persona and puf_select and puf_disable[0]*/
+    } else if (addr == PUF_DISABLE) {
+        /* puf_disable */
+        return puf->puf_disable;
+    } else {
+        qemu_log_mask(LOG_GUEST_ERROR,
+            "clint: invalid read: 0x%" HWADDR_PRIx "\n", addr);
+    }
+
+    return 0L;
+}
+
+/* CPU wrote to the puf */
+static void puf_write(void *opaque, hwaddr addr, uint64_t value,
+        unsigned size)
+{
+    PUFState *puf = opaque;
+
+    /* writes must be 4 byte aligned words */
+    if ((addr & 0x7) != 0 || size != 8) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+            "clint: invalid write size %u: 0x%" HWADDR_PRIx "\n", size, addr);
+        return;
+    }
+
+    if (addr >= PUF_SELECT) {
+        /* puf_select */
+        puf->puf_select = value;
+        return;
+    } else if (addr >= PUF_READOUT) {
+        /* puf_readout writes are ignored */
+        return;
+    } else if (addr == PUF_DISABLE) {
+        /* puf_disable is one bit long, and cannot be cleared */
+        puf->puf_disable = (puf->puf_disable | value) & 0x1;
+        return;
+    } else {
+        qemu_log_mask(LOG_GUEST_ERROR,
+            "clint: invalid write: 0x%" HWADDR_PRIx "\n", addr);
+    }
+}
+
+static const MemoryRegionOps puf_ops = {
+    .read = puf_read,
+    .write = puf_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .valid = {
+        .min_access_size = 8,
+        .max_access_size = 8
+    }
+};
+
+static Property puf_properties[] = {
+    DEFINE_PROP_UINT64("persona", PUFState, persona, 0),
+    DEFINE_PROP_UINT64("puf_select", PUFState, puf_select, 0),
+    DEFINE_PROP_UINT32("puf_disable", PUFState, puf_disable, 0),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void puf_realize(DeviceState *dev, Error **errp)
+{
+    PUFState *s = PUF(dev);
+    memory_region_init_io(&s->mmio, OBJECT(dev), &puf_ops, s,
+                          TYPE_PUF, 0x20);
+    sysbus_init_mmio(SYS_BUS_DEVICE(dev), &s->mmio);
+}
+
+static void puf_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    dc->realize = puf_realize;
+    dc->props = puf_properties;
+}
+
+static const TypeInfo puf_info = {
+    .name          = TYPE_PUF,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(PUFState),
+    .class_init    = puf_class_init,
+};
+
+static void puf_register_types(void)
+{
+    type_register_static(&puf_info);
+}
+
+type_init(puf_register_types)
+
+/*
+ * Create PUF device.
+ */
+DeviceState *puf_create(hwaddr addr, hwaddr size, uint64_t persona)
+{
+    DeviceState *dev = qdev_create(NULL, TYPE_PUF);
+    qdev_prop_set_uint64(dev, "persona", persona);
+    qdev_prop_set_uint64(dev, "puf_select", 0);
+    qdev_prop_set_uint32(dev, "puf_disable", false);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, addr);
+    return dev;
+}
diff --git a/hw/riscv/spike.c b/hw/riscv/spike.c
index b0f0e97a1d..046f2e5923 100644
--- a/hw/riscv/spike.c
+++ b/hw/riscv/spike.c
@@ -49,6 +49,8 @@ static const struct MemmapEntry {
     hwaddr size;
 } spike_memmap[] = {
     [SPIKE_MROM] =     {     0x1000,    0x11000 },
+    [SPIKE_PUF] =      {   0x200000,       0x20 }, // PUF device
+    [SPIKE_ELFLD] =    {  0x1000000,     0x1000 },
     [SPIKE_CLINT] =    {  0x2000000,    0x10000 },
     [SPIKE_DRAM] =     { 0x80000000,        0x0 },
 };
@@ -170,6 +172,7 @@ static void spike_v1_10_0_board_init(MachineState *machine)
     MemoryRegion *system_memory = get_system_memory();
     MemoryRegion *main_mem = g_new(MemoryRegion, 1);
     MemoryRegion *mask_rom = g_new(MemoryRegion, 1);
+    MemoryRegion *elfld_rom = g_new(MemoryRegion, 1);
     int i;

     /* Initialize SOC */
@@ -202,7 +205,9 @@ static void spike_v1_10_0_board_init(MachineState *machine)
     }

     /* reset vector */
-    uint32_t reset_vec[8] = {
+    char *reset_vec;
+    uint32_t reset_vec_size = 0;
+    uint32_t default_reset_vec[8] = {
         0x00000297,                  /* 1:  auipc  t0, %pcrel_hi(dtb) */
         0x02028593,                  /*     addi   a1, t0, %pcrel_lo(1b) */
         0xf1402573,                  /*     csrr   a0, mhartid  */
@@ -218,22 +223,57 @@ static void spike_v1_10_0_board_init(MachineState *machine)
                                      /* dtb: */
     };

-    /* copy in the reset vector in little_endian byte order */
-    for (i = 0; i < sizeof(reset_vec) >> 2; i++) {
-        reset_vec[i] = cpu_to_le32(reset_vec[i]);
+    /* the reset vector is in little_endian byte order */
+    for (i = 0; i < sizeof(default_reset_vec) >> 2; i++) {
+        default_reset_vec[i] = cpu_to_le32(default_reset_vec[i]);
     }
-    rom_add_blob_fixed_as("mrom.reset", reset_vec, sizeof(reset_vec),
+
+    /* Load custom bootloader, if requested, else use default above */
+    if (machine->firmware) {
+      FILE *bootloader_file;
+
+      bootloader_file = fopen ( machine->firmware , "rb" );
+      if( !bootloader_file ) perror("Failed to open the bootloader file."),exit(1);
+
+      fseek( bootloader_file , 0L , SEEK_END);
+      reset_vec_size = ftell( bootloader_file );
+      rewind( bootloader_file );
+
+      reset_vec = (char*)malloc(reset_vec_size * sizeof(char));
+      if( !reset_vec ) fclose(bootloader_file),fputs("Failed to allocate space to read the bootloader file.",stderr),exit(1);
+
+      if( 1!=fread( reset_vec , reset_vec_size, 1 , bootloader_file) )
+        fclose(bootloader_file),free(reset_vec),fputs("Failed to read entire bootloader file.",stderr),exit(1);
+
+      fclose(bootloader_file);
+    } else {
+      reset_vec = (char*)default_reset_vec;
+      reset_vec_size = sizeof(default_reset_vec);
+    }
+
+    /* copy in the reset vector */
+    rom_add_blob_fixed_as("mrom.reset", reset_vec, reset_vec_size,
                           memmap[SPIKE_MROM].base, &address_space_memory);

     /* copy in the device tree */
     if (fdt_pack(s->fdt) || fdt_totalsize(s->fdt) >
-            memmap[SPIKE_MROM].size - sizeof(reset_vec)) {
+            memmap[SPIKE_MROM].size - reset_vec_size) {
         error_report("not enough space to store device-tree");
         exit(1);
     }
     qemu_fdt_dumpdtb(s->fdt, fdt_totalsize(s->fdt));
     rom_add_blob_fixed_as("mrom.fdt", s->fdt, fdt_totalsize(s->fdt),
-                          memmap[SPIKE_MROM].base + sizeof(reset_vec),
+                          memmap[SPIKE_MROM].base + reset_vec_size,
+                          &address_space_memory);
+
+    /* elf loader module */
+    memory_region_init_rom(elfld_rom, NULL, "riscv.spike.elfldr",
+                           memmap[SPIKE_ELFLD].size, &error_fatal);
+    memory_region_add_subregion(system_memory, memmap[SPIKE_ELFLD].base,
+        elfld_rom);
+    uint64_t oxo[2] = { 0x0L, 0x0L };
+    rom_add_blob_fixed_as("elfldr.status", oxo, 0x10,
+                          memmap[SPIKE_ELFLD].base,
                           &address_space_memory);

     /* initialize HTIF using symbols found in load_kernel */
@@ -242,6 +282,10 @@ static void spike_v1_10_0_board_init(MachineState *machine)
     /* Core Local Interruptor (timer and IPI) */
     sifive_clint_create(memmap[SPIKE_CLINT].base, memmap[SPIKE_CLINT].size,
         smp_cpus, SIFIVE_SIP_BASE, SIFIVE_TIMECMP_BASE, SIFIVE_TIME_BASE);
+
+    /* PUF */
+    puf_create(memmap[SPIKE_PUF].base, memmap[SPIKE_PUF].size,
+        0xDEADBEEFABADCAFEL);
 }

 static void spike_v1_09_1_board_init(MachineState *machine)
@@ -281,13 +325,42 @@ static void spike_v1_09_1_board_init(MachineState *machine)
     }

     /* reset vector */
-    uint32_t reset_vec[8] = {
+    char *reset_vec;
+    uint32_t reset_vec_size = 0;
+    uint32_t default_reset_vec[8] = {
         0x297 + memmap[SPIKE_DRAM].base - memmap[SPIKE_MROM].base, /* lui */
         0x00028067,                   /* jump to DRAM_BASE */
         0x00000000,                   /* reserved */
         memmap[SPIKE_MROM].base + sizeof(reset_vec), /* config string pointer */
         0, 0, 0, 0                    /* trap vector */
     };
+    /* the reset vector is in little_endian byte order */
+    for (i = 0; i < sizeof(default_reset_vec) >> 2; i++) {
+        default_reset_vec[i] = cpu_to_le32(default_reset_vec[i]);
+    }
+
+    /* Load custom bootloader, if requested, else use default above */
+    if (machine->firmware) {
+      FILE *bootloader_file;
+
+      bootloader_file = fopen ( machine->firmware , "rb" );
+      if( !bootloader_file ) perror("Failed to open the bootloader file."),exit(1);
+
+      fseek( bootloader_file , 0L , SEEK_END);
+      reset_vec_size = ftell( bootloader_file );
+      rewind( bootloader_file );
+
+      reset_vec = (char*)malloc(reset_vec_size * sizeof(char));
+      if( !reset_vec ) fclose(bootloader_file),fputs("Failed to allocate space to read the bootloader file.",stderr),exit(1);
+
+      if( 1!=fread( reset_vec , reset_vec_size, 1 , bootloader_file) )
+        fclose(bootloader_file),free(reset_vec),fputs("Failed to read entire bootloader file.",stderr),exit(1);
+
+      fclose(bootloader_file);
+    } else {
+      reset_vec = (char*)default_reset_vec;
+      reset_vec_size = sizeof(default_reset_vec);
+    }

     /* part one of config string - before memory size specified */
     const char *config_string_tmpl =
@@ -327,16 +400,17 @@ static void spike_v1_09_1_board_init(MachineState *machine)
     g_free(isa);
     size_t config_string_len = strlen(config_string);

-    /* copy in the reset vector in little_endian byte order */
-    for (i = 0; i < sizeof(reset_vec) >> 2; i++) {
-        reset_vec[i] = cpu_to_le32(reset_vec[i]);
-    }
-    rom_add_blob_fixed_as("mrom.reset", reset_vec, sizeof(reset_vec),
+    /* copy in the reset vector */
+    rom_add_blob_fixed_as("mrom.reset", reset_vec, reset_vec_size,
                           memmap[SPIKE_MROM].base, &address_space_memory);

     /* copy in the config string */
+    if (config_string_len > (memmap[SPIKE_MROM].size - reset_vec_size) ) {
+        error_report("not enough space to store device-tree");
+        exit(1);
+    }
     rom_add_blob_fixed_as("mrom.reset", config_string, config_string_len,
-                          memmap[SPIKE_MROM].base + sizeof(reset_vec),
+                          memmap[SPIKE_MROM].base + reset_vec_size,
                           &address_space_memory);

     /* initialize HTIF using symbols found in load_kernel */
diff --git a/hw/riscv/virt.c b/hw/riscv/virt.c
index 66dc4e07c3..258e2a3fe1 100644
--- a/hw/riscv/virt.c
+++ b/hw/riscv/virt.c
@@ -51,6 +51,7 @@ static const struct MemmapEntry {
     [VIRT_DEBUG] =    {        0x0,      0x100 },
     [VIRT_MROM] =     {     0x1000,    0x11000 },
     [VIRT_TEST] =     {   0x100000,     0x1000 },
+    [VIRT_PUF] =      {   0x200000,       0x20 }, // PUF device
     [VIRT_CLINT] =    {  0x2000000,    0x10000 },
     [VIRT_PLIC] =     {  0xc000000,  0x4000000 },
     [VIRT_UART0] =    { 0x10000000,      0x100 },
@@ -269,7 +270,9 @@ static void riscv_virt_board_init(MachineState *machine)
     firmware_entry = riscv_load_firmware_kernel_initrd(machine, fdt);

     /* reset vector */
-    uint32_t reset_vec[8] = {
+    char *reset_vec;
+    uint32_t reset_vec_size = 0;
+    uint32_t default_reset_vec[8] = {
         0x00000297,                  /* 1:  auipc  t0, %pcrel_hi(dtb) */
         0x02028593,                  /*     addi   a1, t0, %pcrel_lo(1b) */
         0xf1402573,                  /*     csrr   a0, mhartid  */
@@ -285,22 +288,45 @@ static void riscv_virt_board_init(MachineState *machine)
                                      /* dtb: */
     };

+    /* Load custom bootloader, if requested, else use default above */
+    if (machine->firmware) {
+      FILE *bootloader_file;
+
+      bootloader_file = fopen ( machine->firmware , "rb" );
+      if( !bootloader_file ) perror("Failed to open the bootloader file."),exit(1);
+
+      fseek( bootloader_file , 0L , SEEK_END);
+      reset_vec_size = ftell( bootloader_file );
+      rewind( bootloader_file );
+
+      reset_vec = (char*)malloc(reset_vec_size * sizeof(char));
+      if( !reset_vec ) fclose(bootloader_file),fputs("Failed to allocate space to read the bootloader file.",stderr),exit(1);
+
+      if( 1!=fread( reset_vec , reset_vec_size, 1 , bootloader_file) )
+        fclose(bootloader_file),free(reset_vec),fputs("Failed to read entire bootloader file.",stderr),exit(1);
+
+      fclose(bootloader_file);
+    } else {
+      reset_vec = (char*)default_reset_vec;
+      reset_vec_size = sizeof(default_reset_vec);
+    }
+
     /* copy in the reset vector in little_endian byte order */
     for (i = 0; i < sizeof(reset_vec) >> 2; i++) {
         reset_vec[i] = cpu_to_le32(reset_vec[i]);
     }
-    rom_add_blob_fixed_as("mrom.reset", reset_vec, sizeof(reset_vec),
+    rom_add_blob_fixed_as("mrom.reset", reset_vec, reset_vec_size,
                           memmap[VIRT_MROM].base, &address_space_memory);

     /* copy in the device tree */
     if (fdt_pack(s->fdt) || fdt_totalsize(s->fdt) >
-            memmap[VIRT_MROM].size - sizeof(reset_vec)) {
+            memmap[VIRT_MROM].size - reset_vec_size) {
         error_report("not enough space to store device-tree");
         exit(1);
     }
     qemu_fdt_dumpdtb(s->fdt, fdt_totalsize(s->fdt));
     rom_add_blob_fixed_as("mrom.fdt", s->fdt, fdt_totalsize(s->fdt),
-                          memmap[VIRT_MROM].base + sizeof(reset_vec),
+                          memmap[VIRT_MROM].base + reset_vec_size,
                           &address_space_memory);

     /* create PLIC hart topology configuration string */
@@ -331,6 +357,9 @@ static void riscv_virt_board_init(MachineState *machine)
         SIFIVE_SIP_BASE, SIFIVE_TIMECMP_BASE, SIFIVE_TIME_BASE);
     sifive_test_create(memmap[VIRT_TEST].base);

+    puf_create(memmap[VIRT_PUF].base, memmap[VIRT_PUF].size,
+        0xDEADBEEFABADCAFEL);
+
     for (i = 0; i < VIRTIO_COUNT; i++) {
         sysbus_create_simple("virtio-mmio",
             memmap[VIRT_VIRTIO].base + i * memmap[VIRT_VIRTIO].size,
diff --git a/include/hw/riscv/puf.h b/include/hw/riscv/puf.h
new file mode 100644
index 0000000000..724a893c5e
--- /dev/null
+++ b/include/hw/riscv/puf.h
@@ -0,0 +1,32 @@
+/*
+ * PUF
+ */
+
+#ifndef HW_PUF_H
+#define HW_PUF_H
+
+#define TYPE_PUF "riscv.puf"
+
+#define PUF(obj) \
+    OBJECT_CHECK(PUFState, (obj), TYPE_PUF)
+
+typedef struct PUFState {
+    /*< private >*/
+    SysBusDevice parent_obj;
+
+    /*< public >*/
+    MemoryRegion mmio;
+    uint64_t persona;
+    uint64_t puf_select;
+    uint32_t puf_disable;
+} PUFState;
+
+DeviceState *puf_create(hwaddr addr, hwaddr size, uint64_t persona);
+
+enum {
+    PUF_SELECT     = 0x00,
+    PUF_READOUT    = 0x08,
+    PUF_DISABLE    = 0x10
+};
+
+#endif
diff --git a/include/hw/riscv/spike.h b/include/hw/riscv/spike.h
index 641b70da67..0594a86a71 100644
--- a/include/hw/riscv/spike.h
+++ b/include/hw/riscv/spike.h
@@ -31,6 +31,8 @@ typedef struct {

 enum {
     SPIKE_MROM,
+    SPIKE_PUF,
+    SPIKE_ELFLD,
     SPIKE_CLINT,
     SPIKE_DRAM
 };
diff --git a/include/hw/riscv/virt.h b/include/hw/riscv/virt.h
index 91163d6cbf..8d84454f25 100644
--- a/include/hw/riscv/virt.h
+++ b/include/hw/riscv/virt.h
@@ -34,6 +34,7 @@ enum {
     VIRT_DEBUG,
     VIRT_MROM,
     VIRT_TEST,
+    VIRT_PUF,
     VIRT_CLINT,
     VIRT_PLIC,
     VIRT_UART0,
diff --git a/target/riscv/cpu.h b/target/riscv/cpu.h
index c2ff0d30fb..92e7ed4ec2 100644
--- a/target/riscv/cpu.h
+++ b/target/riscv/cpu.h
@@ -177,6 +177,42 @@ struct CPURISCVState {
     target_ulong sscratch;
     target_ulong mscratch;

+    // <SANCTUM>
+    // ## The core state referenced by various CSRs (registers) introduced by Sanctum is declared here.
+    // ### Enclave virtual base and mask
+    // (per-core) registers
+    // ( defines a virtual region for which enclave page tables are used in
+    //   place of OS-controlled page tables)
+    // (machine-mode non-standard read/write)
+    target_ulong mevbase;
+    target_ulong mevmask;
+
+    // ### Enclave page table base
+    // (per core) register
+    // ( pointer to a separate page table data structure used to translate enclave
+    //   virtual addresses)
+    // (machine-mode non-standard read/write)
+    target_ulong meatp;
+
+    // ### DRAM bitmap
+    // (per core) registers (OS and Enclave)
+    // ( white-lists the DRAM regions the core is allowed to access via OS and
+    //   enclave virtual addresses)
+    // (machine-mode non-standard read/write)
+    target_ulong mmrbm;
+    target_ulong memrbm;
+
+    // ### Protected region base and mask
+    // (per core) registers (OS and Enclave)
+    // ( these are used to prevent address translation into a specific range of
+    //   physical addresses, for example to protect the security monitor from all software)
+    // (machine-mode non-standard read/write)
+    target_ulong mparbase;
+    target_ulong mparmask;
+    target_ulong meparbase;
+    target_ulong meparmask;
+    // </SANCTUM>
+
     /* temporary htif regs */
     uint64_t mfromhost;
     uint64_t mtohost;
diff --git a/target/riscv/cpu_bits.h b/target/riscv/cpu_bits.h
index 926afd142d..6bacd8ea0f 100644
--- a/target/riscv/cpu_bits.h
+++ b/target/riscv/cpu_bits.h
@@ -110,6 +110,14 @@
 #define CSR_HPMCOUNTER29H   0xc9d
 #define CSR_HPMCOUNTER30H   0xc9e
 #define CSR_HPMCOUNTER31H   0xc9f
+// <SANCTUM>
+  /*
+  // ### TRNG (random number generator)
+  // (user-mode non-standard read-only)
+  // (per core) register
+  */
+  #define CSR_TRNG 0xcc0
+// </SANCTUM>

 /* Machine Timers and Counters */
 #define CSR_MCYCLE          0xb00
@@ -201,6 +209,43 @@
 #define CSR_DPC             0x7b1
 #define CSR_DSCRATCH        0x7b2

+// <SANCTUM>
+  // ## The addresses of various CSRs (registers) introduced by Sanctum are given here.
+
+  // ### Enclave virtual base and mask
+  // (per-core) registers
+  // ( defines a virtual region for which enclave page tables are used in
+  //   place of OS-controlled page tables)
+  // (machine-mode non-standard read/write)
+  #define CSR_MEVBASE 0x7c0
+  #define CSR_MEVMASK 0x7c1
+
+  // ### Enclave page table base
+  // (per core) register
+  // ( pointer to a separate page table data structure used to translate enclave
+  //   virtual addresses)
+  // (machine-mode non-standard read/write)
+  #define CSR_MEATP 0x7c2
+
+  // ### DRAM bitmap
+  // (per core) registers (OS and Enclave)
+  // ( white-lists the DRAM regions the core is allowed to access via OS and
+  //   enclave virtual addresses)
+  // (machine-mode non-standard read/write)
+  #define CSR_MMRBM 0x7c3
+  #define CSR_MEMRBM 0x7c4
+
+  // ### Protected region base and mask
+  // (per core) registers (OS and Enclave)
+  // ( these are used to prevent address translation into a specific range of
+  //   physical addresses, for example to protect the security monitor from all software)
+  // (machine-mode non-standard read/write)
+  #define CSR_MPARBASE 0x7c5
+  #define CSR_MPARMASK 0x7c6
+  #define CSR_MEPARBASE 0x7c7
+  #define CSR_MEPARMASK 0x7c8
+// </SANCTUM>
+
 /* Performance Counters */
 #define CSR_MHPMCOUNTER3    0xb03
 #define CSR_MHPMCOUNTER4    0xb04
diff --git a/target/riscv/csr.c b/target/riscv/csr.c
index 67381e765a..248a4e660c 100644
--- a/target/riscv/csr.c
+++ b/target/riscv/csr.c
@@ -22,6 +22,7 @@
 #include "cpu.h"
 #include "qemu/main-loop.h"
 #include "exec/exec-all.h"
+#include "trng.h"

 /* CSR function table */

@@ -606,7 +607,7 @@ static int rmw_mnxti(CPURISCVState *env, int csrno, target_ulong *ret_value,
     /*
      * TODO - implement complete mnxti semantics
      *
-     * the CLIC state is currenetly not accessible from target/riscv
+     * the CLIC state is currenetly not accessible from target/riscv
      * as cpu implementations can't include anything from include/hw
      * so the CLIC state needs to be in a CPU accessible structure.
      *
@@ -928,6 +929,129 @@ static int write_pmpaddr(CPURISCVState *env, int csrno, target_ulong val)

 #endif

+/*
+ * Sanctum Core Configuration
+ */
+
+static int read_mevbase(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->mevbase;
+    return 0;
+}
+
+static int write_mevbase(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->mevbase = val;
+    return 0;
+}
+
+static int read_mevmask(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->mevmask;
+    return 0;
+}
+
+static int write_mevmask(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->mevmask = val;
+    return 0;
+}
+
+static int read_meatp(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->meatp;
+    return 0;
+}
+
+static int write_meatp(CPURISCVState *env, int csrno, target_ulong val)
+{
+    tlb_flush(CPU(riscv_env_get_cpu(env)));
+    env->meatp = val;
+    return 0;
+}
+
+static int read_mmrbm(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->mmrbm;
+    return 0;
+}
+
+static int write_mmrbm(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->mmrbm = val;
+    return 0;
+}
+
+static int read_memrbm(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->memrbm;
+    return 0;
+}
+
+static int write_memrbm(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->memrbm = val;
+    return 0;
+}
+
+static int read_mparbase(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->mparbase;
+    return 0;
+}
+
+static int write_mparbase(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->mparbase = val;
+    return 0;
+}
+
+static int read_mparmask(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->mparmask;
+    return 0;
+}
+
+static int write_mparmask(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->mparmask = val;
+    return 0;
+}
+
+static int read_meparbase(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->meparbase;
+    return 0;
+}
+
+static int write_meparbase(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->meparbase = val;
+    return 0;
+}
+
+static int read_meparmask(CPURISCVState *env, int csrno, target_ulong *val)
+{
+    *val = env->meparmask;
+    return 0;
+}
+
+static int write_meparmask(CPURISCVState *env, int csrno, target_ulong val)
+{
+    env->meparmask = val;
+    return 0;
+}
+
+
+/*
+ * TRNG
+ */
+static int read_trng(CPURISCVState *env, int csrno, target_ulong *val)
+{
+   *val = trng();
+   return 0;
+}
+
 /*
  * riscv_csrrw - read and/or update control and status register
  *
@@ -1072,6 +1196,17 @@ static riscv_csr_operations csr_ops[CSR_TABLE_SIZE] = {
     [CSR_PMPCFG0  ... CSR_PMPADDR9] =  { pmp,   read_pmpcfg,  write_pmpcfg   },
     [CSR_PMPADDR0 ... CSR_PMPADDR15] = { pmp,   read_pmpaddr, write_pmpaddr  },

+    /* Sanctum Core Configuration */
+    [CSR_MEVBASE] =             { any,  read_mevbase,     write_mevbase      },
+    [CSR_MEVMASK] =             { any,  read_mevmask,     write_mevmask      },
+    [CSR_MEATP] =               { any,  read_meatp,       write_meatp        },
+    [CSR_MMRBM] =               { any,  read_mmrbm,       write_mmrbm        },
+    [CSR_MEMRBM] =              { any,  read_memrbm,      write_memrbm       },
+    [CSR_MPARBASE] =            { any,  read_mparbase,    write_mparbase     },
+    [CSR_MPARMASK] =            { any,  read_mparmask,    write_mparmask     },
+    [CSR_MEPARBASE] =           { any,  read_meparbase,   write_meparbase    },
+    [CSR_MEPARMASK] =           { any,  read_meparmask,   write_meparmask    },
+
     /* Performance Counters */
     [CSR_HPMCOUNTER3   ... CSR_HPMCOUNTER31] =    { ctr,  read_zero          },
     [CSR_MHPMCOUNTER3  ... CSR_MHPMCOUNTER31] =   { any,  read_zero          },
@@ -1081,6 +1216,9 @@ static riscv_csr_operations csr_ops[CSR_TABLE_SIZE] = {
     [CSR_MHPMCOUNTER3H ... CSR_MHPMCOUNTER31H] =  { any,  read_zero          },
 #endif

+    /* TRNG */
+    [CSR_TRNG] =                { any,   read_trng,                          },
+
     /* Machine Mode Core Level Interrupt Controller */
     [CSR_MTVT] =                { clic,  read_mtvt, write_mtvt,              },
     [CSR_MNXTI] =               { clic,  NULL,     NULL,     rmw_mnxti       },
diff --git a/target/riscv/pmp.c b/target/riscv/pmp.c
index 3dbb87c69d..6ee4d7965a 100644
--- a/target/riscv/pmp.c
+++ b/target/riscv/pmp.c
@@ -248,7 +248,7 @@ target_ulong pmpcfg_csr_read(CPURISCVState *env, size_t cfg)
     for (size_t b = 0; b < sizeof(target_ulong); b++) {
         size_t i = cfg * sizeof(target_ulong) + b;
         target_ulong val = env->pmp_state.pmp[i].cfg_reg;
-        cfg_val |= (val << (b * 8));
+        cfg_val |= (val << ((target_ulong)b * 8));
     }

     trace_pmpcfg_csr_read(env->mhartid, cfg, cfg_val);
diff --git a/target/riscv/trng.h b/target/riscv/trng.h
new file mode 100644
index 0000000000..2e7ab4d8a3
--- /dev/null
+++ b/target/riscv/trng.h
@@ -0,0 +1,8 @@
+#ifndef _RISCV_TRNG_H
+#define _RISCV_TRNG_H
+ #include <stdlib.h>
+ uint64_t trng()
+{
+  return random() & 0xFF;
+}
+ #endif // _RISCV_TRNG_H
--
2.17.2 (Apple Git-113)


From 581ebc0ff0ee5e59c3b3577b0ffbb30ffaab772a Mon Sep 17 00:00:00 2001
From: Ilia Lebedev <ilebedev@mit.edu>
Date: Wed, 16 Jan 2019 15:23:14 -0500
Subject: [PATCH 2/2] added sanctun enforcement

---
 target/riscv/cpu_helper.c | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/target/riscv/cpu_helper.c b/target/riscv/cpu_helper.c
index 7bf6cbc13b..510cdfded7 100644
--- a/target/riscv/cpu_helper.c
+++ b/target/riscv/cpu_helper.c
@@ -189,8 +189,18 @@ static int get_physical_address(CPURISCVState *env, hwaddr *physical,
     int levels, ptidxbits, ptesize, vm, sum;
     int mxr = get_field(env->mstatus, MSTATUS_MXR);

+    target_ulong mrbm = 0xFFFFFFFFFFFFFFFF;
+    target_ulong parbase = 0xFFFFFFFFFFFFFFFF;
+    target_ulong parmask = 0x0000000000000000;
+
     if (env->priv_ver >= PRIV_VERSION_1_10_0) {
-        base = get_field(env->satp, SATP_PPN) << PGSHIFT;
+        bool is_enclave_walk = ((addr & env->mevmask) == env->mevbase);
+        base = is_enclave_walk ? ( get_field(env->meatp, SATP_PPN) << PGSHIFT )
+                               : ( get_field(env->satp, SATP_PPN) << PGSHIFT );
+        mrbm = is_enclave_walk ? env->memrbm : env->mmrbm;
+        parbase = is_enclave_walk ? env->meparbase : env->mparbase;
+        parmask = is_enclave_walk ? env->meparmask : env->mparmask;
+
         sum = get_field(env->mstatus, MSTATUS_SUM);
         vm = get_field(env->satp, SATP_MODE);
         switch (vm) {
@@ -256,6 +266,17 @@ restart:
 #endif
         target_ulong ppn = pte >> PTE_PPN_SHIFT;

+        // <SANCTUM>
+        // Check protected address region
+        if ( ((ppn << PGSHIFT) & parmask) == parbase ) {
+          return TRANSLATE_FAIL;
+        }
+        // Check region permission
+        if ( ( (1<<(((ppn << PGSHIFT) >> 15)&0x3F)) & mrbm ) == 0) {
+          return TRANSLATE_FAIL;
+        }
+        // </SANCTUM>
+
         if (!(pte & PTE_V)) {
             /* Invalid PTE */
             return TRANSLATE_FAIL;
--
2.17.2 (Apple Git-113)
