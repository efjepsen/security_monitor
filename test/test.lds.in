#include "test_parameters.h"

OUTPUT_ARCH( "riscv" )
ENTRY( boot_entry )

MEMORY
{
  BOOT (x) :      ORIGIN = BOOT_ADDR,       LENGTH = BOOT_MAXLEN
  SM_STATE (w) :  ORIGIN = SM_STATE_ADDR,   LENGTH = SM_STATE_LEN
  SM (wx) :       ORIGIN = SM_ADDR,         LENGTH = SM_LEN
  PAYLOAD (wx) :  ORIGIN = UNTRUSTED_ENTRY, LENGTH = PAYLOAD_MAXLEN
}

SECTIONS
{
  . = ORIGIN(BOOT);
  .data.boot : {
    PROVIDE( boot_entry = . );
    *(.boot.text.entry)
    *(.boot.*)
    *(.boot)
  } > BOOT
}


SECTIONS
{
  . = ORIGIN(SM_STATE);
  .data.sm : {
    *(.sm.state) /* Your payload goes here */
  } > SM_STATE
}

SECTIONS
{
  . = ORIGIN(SM);
  .text.sm : {
    PROVIDE( sm_entry = . );
    *(.sm) /* Your payload goes here */
  } > SM
}


SECTIONS
{
  . = ORIGIN(PAYLOAD);
  .text : {
    PROVIDE( payload_entry = . );
    *(.text.entry)
    *(.text.*)
    *(.text)
  } > PAYLOAD

  .data ALIGN(0x1000) : {
    *(.data.*)
    *(.data)
  } > PAYLOAD

  .bss ALIGN(0x1000) : {
    *(.bss.*)
    *(.bss)
  } > PAYLOAD

  .rodata ALIGN(0x1000) : {
    *(.rodata.*)
    *(.rodata)
  } > PAYLOAD

  .htif ALIGN(0x1000) (NOLOAD) : {
    PROVIDE( __htif_base = . );
    *(.htif.tohost)
    *(.htif.fromhost)
  } > PAYLOAD

  .region1 ALIGN(0x2000000) (NOLOAD) : { /* Align to the *next* 32MB boundary */
    PROVIDE( region1 = . );
    BYTE(1)
  } > PAYLOAD

  .region2 ALIGN(0x2000000) (NOLOAD) : { /* Align to the *next* 32MB boundary */
    PROVIDE( region2 = . );
    BYTE(1)
  } > PAYLOAD

  .region3 ALIGN(0x2000000) (NOLOAD) : { /* Align to the *next* 32MB boundary */
    PROVIDE( region3 = . );
    BYTE(1)
  } > PAYLOAD
}
